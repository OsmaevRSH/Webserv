/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Config_handler.cpp                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jeldora <jeldora@student.21-school.ru>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/12/26 02:47:25 by jeldora           #+#    #+#             */
/*   Updated: 2020/12/26 02:47:26 by jeldora          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Config.hpp"

// Рабочяя структура для обработчика
typedef ConfigHandler::t_params t_params;

/*
 * -1) Принимаем структуру с полями запроса. И обрабтываем ее тут.
 *
 * 0)	У нас есть структура со всеми полями типо root, index, autoindex и т.д...
 * 		Заходя глубже в блочные директивы, обработчик будет менять эти поля на более приорететные.
 * 		Дойдя до конечной точки, мы на основании содержимого этой структуры принимаем решение, что отдать клиенту.
 *
 * 1)	Ищем сервера с соответствующим ip и портом.
 * 		Если не находим, то выдаем ошибку.
 * 		Что, если есть сервера без указанного ip?
 *
 * 2)	Ищем среди серверов совпадение по server_name. Если не находим, выбираем первый.
 *
 * 3)	Ищем совпадение по маршрутам (route), и если маршрут имеет подмаршруты, углубляемся в них.
 * 		Если маршрут имеет первый аргумент блочной директивы '=' и он совпадает с строкой запроса
 * 		без аргументов, то мы останавливаемся на этом маршруте и дальше не ищем. В иных случаях,
 * 		мы запоминаем максимально совпадающий маршрут (но меньшей или равной длины),
 * 		и если нет других на этом же уровне, то выбираем его. Вложенные маршруты задаются не
 * 		относительно родительского.
 *		Есть ньюанс, если нам прислали директиву, и она обрабатывается индексом. Тогда запрос
 *		обрабатывается заново с соответствующим индексным файлом.
 *
 * 4)	И вот, у нас есть структура с такими полями:
 *		path_to_page
 *		ip
 *		port
 *		server_name
 *		allow_methods
 *		max_body_size
 *		error_pages
 *
 *	5)	Далее смотрим, разрешен ли тот метод, который был в запросе.
 *		Смотрим, есть ли такая страница.
 *		Смотрим, не больше ли content-length чем max_body_size.
 *		В случае ошибки, ищем соответствующую страницу ошибки среди error_pages.
 *		Либо возвращаем стандартную.
 *
 */
